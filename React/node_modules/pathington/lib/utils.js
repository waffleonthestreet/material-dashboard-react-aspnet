"use strict";

exports.__esModule = true;
exports.parseStringPath = exports.getNormalizedParseKey = exports.createGetNormalizedCreateKey = exports.shouldBeInQuotes = exports.shouldBeInBrackets = exports.map = exports.isQuotedKey = exports.isNumericKey = void 0;

var _constants = require("./constants");

// constants

/**
 * @function isNumericKey
 *
 * @description
 * is the key passed a numeric string
 *
 * @param {string} key the key to test
 * @returns {boolean} is the key passed a numeric string
 */
var isNumericKey = function isNumericKey(key) {
  return !!(key && key.length) && _constants.NUMBER.test(key);
};
/**
 * @function isQuotedKey
 *
 * @description
 * is the key passed a quoted key
 *
 * @param {string} key the key to test
 * @returns {boolean} is the key a quoted key
 */


exports.isNumericKey = isNumericKey;

var isQuotedKey = function isQuotedKey(key) {
  return _constants.QUOTED_KEY.test(key);
};
/**
 * @function map
 *
 * @description
 * map the array to a new array based on fn
 *
 * @param {Array<*>} array the array to map
 * @param {function} fn the function to call with each iteration value
 * @returns {Array<*>} the mapped array
 */


exports.isQuotedKey = isQuotedKey;

var map = function map(array, fn) {
  var length = array.length;
  var mapped = [];

  for (var index = 0; index < length; index++) {
    mapped[index] = fn(array[index]);
  }

  return mapped;
};
/**
 * @function shouldBeInBrackets
 *
 * @description
 * should the key passed be encased in brackets when in the path string
 *
 * @param {*} key the key that is being added to the path string
 * @returns {boolean} should the key be in brackets
 */


exports.map = map;

var shouldBeInBrackets = function shouldBeInBrackets(key) {
  return typeof key === 'number' || isNumericKey(key) || isQuotedKey(key);
};
/**
 * @function shouldBeInQuotes
 *
 * @description
 * should the key passed be encased in quotes when in the path string
 *
 * @param {*} key the key that is being added to the path string
 * @returns {boolean} should the key be in quotes
 */


exports.shouldBeInBrackets = shouldBeInBrackets;

var shouldBeInQuotes = function shouldBeInQuotes(key) {
  return _constants.WHITE_SPACE.test(key) || !_constants.VALID_KEY.test(key);
};
/**
 * @function createGetNormalizedCreateKey
 *
 * @description
 * get the normalized path string based on the quote and key passed
 *
 * @param {string} [quote="] the quote string to use
 * @returns {function(string, *): string}
 */


exports.shouldBeInQuotes = shouldBeInQuotes;

var createGetNormalizedCreateKey = function createGetNormalizedCreateKey(quote) {
  return function (existingString, key) {
    var normalizedKey = shouldBeInQuotes(key) ? "" + quote + key + quote : key;
    return existingString + (shouldBeInBrackets(normalizedKey) ? "[" + normalizedKey + "]" : "." + normalizedKey);
  };
};
/**
 * @function getNormalizedParseKey
 *
 * @description
 * get the key as a number if parseable, or as a quoted string if applicable
 *
 * @param {string} key the key to try to parse
 * @returns {number|string} the parsed key
 */


exports.createGetNormalizedCreateKey = createGetNormalizedCreateKey;

var getNormalizedParseKey = function getNormalizedParseKey(key) {
  var cleanKey = isQuotedKey(key) ? key.slice(1, key.length - 1) : key;
  return isNumericKey(cleanKey) ? +cleanKey : cleanKey;
};
/**
 * @function parsePath
 *
 * @description
 * parse the path, memoizing the results
 *
 * @param {string} path the path to parse
 * @returns {Array<number|string>} the parsed path
 */


exports.getNormalizedParseKey = getNormalizedParseKey;

var parseStringPath = function parseStringPath(path) {
  if (_constants.CACHE.results[path]) {
    return _constants.CACHE.results[path];
  }

  if (_constants.CACHE.size > _constants.MAX_CACHE_SIZE) {
    _constants.CACHE.clear();
  }

  _constants.CACHE.results[path] = path ? map(path.match(_constants.DOTTY_WITH_BRACKETS_SYNTAX), getNormalizedParseKey) : [path];
  _constants.CACHE.size++;
  return _constants.CACHE.results[path];
};

exports.parseStringPath = parseStringPath;