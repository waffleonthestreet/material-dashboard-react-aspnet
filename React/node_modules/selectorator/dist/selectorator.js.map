{"version":3,"file":"selectorator.js","sources":["../src/constants.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["export const INVALID_ARRAY_PATHS_MESSAGE: string =\n  'You have not provided any values for paths, so no values can be retrieved from state.';\n\nexport const INVALID_PATHS_MESSAGE: string = [\n  'First parameter passed must be either an array or a plain object.',\n  'If you are creating a standard selector, pass an array of either',\n  'properties on the state to retrieve, or custom selector functions.',\n  'If creating a structured selector, pass a plain object with source',\n  'and destination properties, where source is an array of properties',\n  'or custom selector functions, and destination is an array of property',\n  'names to assign the values from source to.',\n].join(' ');\n\nexport const INVALID_OBJECT_PATH_MESSAGE: string = `\nWhen providing an object path, you must provide the following properties:\n  * path: the path to retrieve, e.g. \"foo.bar\"\n  * argIndx: the index of the argument to retrieve the path from\n`.trim();\n\nexport const INVALID_PATH_MESSAGE: string = `\nPath provided is of invalid type. It can be any one of the following values:\n  * Dot-bracket notation, e.g. \"foo.bar\" or \"bar[0].baz\"\n  * Number index, e.g. 0\n  * Object {path, argIndex}, e.g. {path: \"foo.bar\", argIndex: 1}\n  * Selector function\n`.trim();\n","// external dependencies\nimport { deepEqual as isDeeplyEqual, sameValueZeroEqual } from 'fast-equals';\nimport { createIdentity } from 'identitate';\nimport { createSelectorCreator, defaultMemoize } from 'reselect';\nimport { get } from 'unchanged';\n\n// constants\nimport { INVALID_OBJECT_PATH_MESSAGE, INVALID_PATH_MESSAGE } from './constants';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @private\n *\n * @function isFunctionPath\n *\n * @description\n * is the path a function\n *\n * @param path the path to test\n * @param type the typeof value for the path\n * @returns is the path a function\n */\nexport const isFunctionPath = (\n  path: selectorator.Path,\n  type: string,\n): path is Function => type === 'function';\n\n/**\n * @private\n *\n * @function isObjectPath\n *\n * @description\n * is the path an object\n *\n * @param path the path to test\n * @param type the typeof value for the path\n * @returns is the path an object\n */\nexport const isObjectPath = (\n  path: selectorator.Path,\n  type: string,\n): path is selectorator.PathObject => !!path && type === 'object';\n\n/**\n * @private\n *\n * @function isUnchangedPath\n *\n * @description\n * is the path an unchanged path value\n *\n * @param path the path to test\n * @param type the typeof value for the path\n * @returns is the path an unchanged path value\n */\nexport const isUnchangedPath = (\n  path: selectorator.Path,\n  type: string,\n): path is string | number | (string | number)[] =>\n  type === 'string' || type === 'number' || Array.isArray(path);\n\n/**\n * @private\n *\n * @function createIdentitySelector\n *\n * @description\n * based on the path passed, create the identity function for it or return the function itself\n *\n * @param path nested path to retrieve from the state object\n * @returns identity function to retrieve value from state for given property\n */\nexport const createIdentitySelector = (path: selectorator.Path): Function => {\n  const type: string = typeof path;\n\n  if (isFunctionPath(path, type)) {\n    return path;\n  }\n\n  if (isUnchangedPath(path, type)) {\n    return (state: PlainObject): any => get(path, state);\n  }\n\n  if (isObjectPath(path, type)) {\n    if (\n      hasOwnProperty.call(path, 'path') &&\n      hasOwnProperty.call(path, 'argIndex')\n    ) {\n      const selectorIdentity: Function = createIdentity(path.argIndex);\n\n      return function () {\n        return get(path.path, selectorIdentity.apply(null, arguments));\n      };\n    }\n\n    throw new ReferenceError(INVALID_OBJECT_PATH_MESSAGE);\n  }\n\n  throw new TypeError(INVALID_PATH_MESSAGE);\n};\n\n/**\n * @private\n *\n * @function getSelectorCreator\n *\n * @description\n * get the creator function to use when generating the selector\n *\n * @param deepEqual should the memoizer be based on strict equality\n * @param isEqual the custom equality method to use when comparing values\n * @param memoizer custom selector memoizer\n * @param memoizerParams custom parameters to pass to the memoizer function\n * @returns function to create selector with\n */\nexport const getSelectorCreator = ({\n  deepEqual = false,\n  isEqual = sameValueZeroEqual,\n  memoizer,\n  memoizerParams = [],\n}: selectorator.Options): Function => {\n  const memoizerFn: Function = memoizer || defaultMemoize;\n  const equals: Function = deepEqual ? isDeeplyEqual : isEqual;\n\n  return (createSelectorCreator as any).call(  // fix strict mode error\n    null,\n    memoizerFn,\n    equals,\n    ...memoizerParams,\n  );\n};\n\n/**\n * @private\n *\n * @function getStandardSelector\n *\n * @description\n * get a standard selector based on the paths and getComputedValue provided\n *\n * @param paths paths to retrieve values from state from\n * @param selectorCreator function to create selector with\n * @param getComputedValue function to compute values with, receiving properties in state based\n *   on paths and returning computed values from them (defaults to pass-through identity function)\n * @returns selector to return computed value from state\n */\nexport const getStandardSelector = (\n  paths: selectorator.Path[],\n  selectorCreator: Function,\n  getComputedValue: Function,\n): Function =>\n  selectorCreator(paths.map(createIdentitySelector), getComputedValue);\n\n/**\n * @private\n *\n * @function getStructuredObject\n *\n * @description\n * get the structured object based on the computed selector values\n *\n * @param properties properties to assign values from state to\n * @returns object of property => selected value pairs\n */\nexport const getStructuredObject = (properties: string[]): Function => (\n  ...values: any[]\n) =>\n  properties.reduce(\n    (\n      structuredObject: PlainObject,\n      property: string,\n      index: number,\n    ): PlainObject => {\n      structuredObject[property] = values[index];\n\n      return structuredObject;\n    },\n    {},\n  );\n\n/**\n * @private\n *\n * @function getStructuredSelector\n *\n * @description\n * get an object of property => selected value pairs bsaed on paths\n *\n * @param paths property => path pairs, where path is state value to retrieve and assign to property\n * @param selectorCreator function to create selector with\n * @returns selector to return structured values from state\n */\nexport const getStructuredSelector = (\n  paths: PlainObject,\n  selectorCreator: Function,\n): Function => {\n  const destinationKeys: string[] = Object.keys(paths);\n  const selectors: Function[] = destinationKeys.map(\n    (key) => createIdentitySelector(paths[key]),\n  );\n\n  return selectorCreator(selectors, getStructuredObject(destinationKeys));\n};\n","// external dependencies\nimport { identity } from 'identitate';\n\n// constants\nimport {\n  INVALID_ARRAY_PATHS_MESSAGE,\n  INVALID_PATHS_MESSAGE,\n} from './constants';\n\n// utils\nimport {\n  getSelectorCreator,\n  getStandardSelector,\n  getStructuredSelector,\n} from './utils';\n\n/**\n * @module selectorator\n */\n\n/**\n * @function createSelector\n *\n * @description\n * create a selector without any boilerplate code\n *\n * @example\n * import createSelector from 'selectorator';\n *\n * const getFilteredItems = createSelector(['items', 'filter.value'], (items, filterValue) => {\n *   return items.filter((item) => {\n *     return item.indexOf(filterValue) !== -1;\n *   });\n * });\n *\n * const state = {\n *   items: ['foo', 'bar', 'foo-bar'],\n *   filter: {\n *     value: 'foo'\n *   }\n * };\n *\n * console.log(getFilteredItems(state)); // ['foo', 'foo-bar'];\n * console.log(getFilteredItems(state)); // ['foo', 'foo-bar'], pulled from cache;\n *\n * @param paths paths to retrieve from state as parameters in getComputedValue, or\n * an object of key => path pairs that will assign path at state to key in structured selector\n * @param getComputedValue function that will accept the values at paths in state as parameters\n * and compute the next result\n * @param options additional options available for selector creation\n * @returns selector for state object passed\n */\n\nfunction createSelector<State extends never, Output extends never>( // overload to signify errors\n  paths: never[], // when path is empty\n): never;\n\nfunction createSelector<State, Output = any>( // overload for getIdentity\n  paths: selectorator.PathWithoutObject[],\n): selectorator.Selector<State, Output>;\n\nfunction createSelector<State extends any[], Output = any>( // overload for getIdentity - multiParam\n  paths: selectorator.Path[],\n): selectorator.SelectorMultiParam<State, Output>;\n\nfunction createSelector<State, Output extends PlainObject = PlainObject>( // overload for structured\n  paths: Output,                                                        // selectors\n): selectorator.Selector<\n  State,\n  {\n    [key in keyof Output]: Output[key] extends ((\n      ...args: any[]\n    ) => infer Return)\n      ? Return\n      : any\n  }\n>;\n\nfunction createSelector<State, Output>( // overload for standard selector\n  paths: selectorator.PathWithoutObject[],\n  getComputedValue: (...args: any) => Output,\n  options?: selectorator.Options,\n): selectorator.Selector<State, Output>;\n\nfunction createSelector<State extends any[], Output>( // overload for selectors with path objects\n  paths: selectorator.Path[],                        // for multiple parameters.\n  getComputedValue: (...args: any) => Output,\n  options?: selectorator.Options,\n): selectorator.SelectorMultiParam<State, Output>;\n\nfunction createSelector<State, Output>( // actual implementation - no changes\n  paths: selectorator.Path[] | PlainObject,\n  getComputedValue: (...args: any) => Output = identity,\n  options: selectorator.Options = {},\n): selectorator.Selector<State, Output> {\n  const selectorCreator: Function = getSelectorCreator(options);\n\n  if (Array.isArray(paths)) {\n    if (!paths.length) {\n      throw new ReferenceError(INVALID_ARRAY_PATHS_MESSAGE);\n    }\n\n    return <any>getStandardSelector(paths, selectorCreator, getComputedValue);\n  }\n  // added null check\n  if (paths && paths !== null && typeof paths === 'object') {\n    return <any>getStructuredSelector(paths, selectorCreator);\n  }\n\n  throw new TypeError(INVALID_PATHS_MESSAGE);\n}\n\nexport default createSelector;\n"],"names":["get","createIdentity","defaultMemoize","isDeeplyEqual","createSelectorCreator"],"mappings":";;;;;;EAAO,IAAM,2BAA2B,GACtC,uFAAuF,CAAC;AAE1F,EAAO,IAAM,qBAAqB,GAAW;MAC3C,mEAAmE;MACnE,kEAAkE;MAClE,oEAAoE;MACpE,oEAAoE;MACpE,oEAAoE;MACpE,uEAAuE;MACvE,4CAA4C;GAC7C,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAEZ,EAAO,IAAM,2BAA2B,GAAW,mMAIlD,CAAC,IAAI,EAAE,CAAC;AAET,EAAO,IAAM,oBAAoB,GAAW,qQAM3C,CAAC,IAAI,EAAE,CAAC;;ECzBT;AACA,EAQA,IAAM,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC;EAEvD;;;;;;;;;;;;AAYA,EAAO,IAAM,cAAc,GAAG,UAC5B,IAAuB,EACvB,IAAY,IACS,OAAA,IAAI,KAAK,UAAU,GAAA,CAAC;EAE3C;;;;;;;;;;;;AAYA,EAAO,IAAM,YAAY,GAAG,UAC1B,IAAuB,EACvB,IAAY,IACwB,OAAA,CAAC,CAAC,IAAI,IAAI,IAAI,KAAK,QAAQ,GAAA,CAAC;EAElE;;;;;;;;;;;;AAYA,EAAO,IAAM,eAAe,GAAG,UAC7B,IAAuB,EACvB,IAAY;MAEZ,OAAA,IAAI,KAAK,QAAQ,IAAI,IAAI,KAAK,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;EAA7D,CAA6D,CAAC;EAEhE;;;;;;;;;;;AAWA,EAAO,IAAM,sBAAsB,GAAG,UAAC,IAAuB;MAC5D,IAAM,IAAI,GAAW,OAAO,IAAI,CAAC;MAEjC,IAAI,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE;UAC9B,OAAO,IAAI,CAAC;OACb;MAED,IAAI,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE;UAC/B,OAAO,UAAC,KAAkB,IAAU,OAAAA,aAAG,CAAC,IAAI,EAAE,KAAK,CAAC,GAAA,CAAC;OACtD;MAED,IAAI,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE;UAC5B,IACE,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC;cACjC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,EACrC;cACA,IAAM,kBAAgB,GAAaC,yBAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;cAEjE,OAAO;kBACL,OAAOD,aAAG,CAAC,IAAI,CAAC,IAAI,EAAE,kBAAgB,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC;eAChE,CAAC;WACH;UAED,MAAM,IAAI,cAAc,CAAC,2BAA2B,CAAC,CAAC;OACvD;MAED,MAAM,IAAI,SAAS,CAAC,oBAAoB,CAAC,CAAC;EAC5C,CAAC,CAAC;EAEF;;;;;;;;;;;;;;AAcA,EAAO,IAAM,kBAAkB,GAAG,UAAC,EAKZ;UAJrB,iBAAiB,EAAjB,sCAAiB,EACjB,eAA4B,EAA5B,4DAA4B,EAC5B,sBAAQ,EACR,sBAAmB,EAAnB,wCAAmB;;MAEnB,IAAM,UAAU,GAAa,QAAQ,IAAIE,uBAAc,CAAC;MACxD,IAAM,MAAM,GAAa,SAAS,GAAGC,oBAAa,GAAG,OAAO,CAAC;MAE7D,OAAO,CAAA,KAACC,8BAA6B,EAAC,IAAI;UACxC,IAAI;UACJ,UAAU;UACV,MAAM,SACH,cAAc,GACjB;EACJ,CAAC,CAAC;EAEF;;;;;;;;;;;;;;AAcA,EAAO,IAAM,mBAAmB,GAAG,UACjC,KAA0B,EAC1B,eAAyB,EACzB,gBAA0B;MAE1B,OAAA,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,sBAAsB,CAAC,EAAE,gBAAgB,CAAC;EAApE,CAAoE,CAAC;EAEvE;;;;;;;;;;;AAWA,EAAO,IAAM,mBAAmB,GAAG,UAAC,UAAoB,IAAe,OAAA;MACrE,gBAAgB;WAAhB,UAAgB,EAAhB,qBAAgB,EAAhB,IAAgB;UAAhB,2BAAgB;;MAEhB,OAAA,UAAU,CAAC,MAAM,CACf,UACE,gBAA6B,EAC7B,QAAgB,EAChB,KAAa;UAEb,gBAAgB,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;UAE3C,OAAO,gBAAgB,CAAC;OACzB,EACD,EAAE,CACH;EAXD,CAWC,GAAA,CAAC;EAEJ;;;;;;;;;;;;AAYA,EAAO,IAAM,qBAAqB,GAAG,UACnC,KAAkB,EAClB,eAAyB;MAEzB,IAAM,eAAe,GAAa,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;MACrD,IAAM,SAAS,GAAe,eAAe,CAAC,GAAG,CAC/C,UAAC,GAAG,IAAK,OAAA,sBAAsB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAA,CAC5C,CAAC;MAEF,OAAO,eAAe,CAAC,SAAS,EAAE,mBAAmB,CAAC,eAAe,CAAC,CAAC,CAAC;EAC1E,CAAC,CAAC;;EC5MF;AACA,EAyFA,SAAS,cAAc;EACrB,KAAwC,EACxC,gBAAqD,EACrD,OAAkC;MADlC,iCAAA,EAAA,sCAAqD;MACrD,wBAAA,EAAA,YAAkC;MAElC,IAAM,eAAe,GAAa,kBAAkB,CAAC,OAAO,CAAC,CAAC;MAE9D,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;UACxB,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;cACjB,MAAM,IAAI,cAAc,CAAC,2BAA2B,CAAC,CAAC;WACvD;UAED,OAAY,mBAAmB,CAAC,KAAK,EAAE,eAAe,EAAE,gBAAgB,CAAC,CAAC;OAC3E;;MAED,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;UACxD,OAAY,qBAAqB,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;OAC3D;MAED,MAAM,IAAI,SAAS,CAAC,qBAAqB,CAAC,CAAC;EAC7C,CAAC;;;;;;;;;;;;"}